---
description: Правила разработки для Flutter мобильного проекта
alwaysApply: true
globs:
  - "**/*.dart"
---

# Cursor Rules для Flutter мобильного проекта

## Общие принципы

- Всегда отвечай на русском языке
- Следуй принципам SOLID и KISS и DRY
- Не добавляй комментарии (ни //, ни /* */, ни #)
- Удаляй неиспользуемый код
- Приоритет чистому, эффективному и поддерживаемому коду
- Следуй лучшим практикам Flutter и Dart

## Структура проекта

- Используй простую структуру: `lib/screens/`, `lib/widgets/`, `lib/services/`, `lib/models/`, `lib/constants/`
- Храни каждый экран в отдельном файле
- Выноси переиспользуемые виджеты в `lib/widgets/`
- Храни сервисы (например, для работы с SharedPreferences) в `lib/services/`
- Используй константы для строк, цветов, размеров в отдельных файлах
- Организация виджетов в `lib/widgets/`:
  - Общие UI виджеты (переиспользуемые компоненты) - в папку `ui/`
  - Виджеты, относящиеся к конкретному экрану - в папку с названием экрана (например, `home/`, `onboarding/`)
- **Создавай `index.dart` файл в каждой папке** для организации публичного API модуля

## Цвета

- Все цвета приложения должны находиться в `lib/constants/colors_const.dart`
- Используй только цвета из `AppColors`, не используй прямые обращения к `Colors.*` (кроме системных цветов типа `Colors.transparent`, которые должны быть определены в `AppColors`)
- Если нужен новый цвет, добавь его в `AppColors` в `colors_const.dart`

## Стиль кода

- Используй `const` конструкторы везде, где возможно
- Предпочитай `final` вместо `var`
- Используй named parameters для функций с более чем 2 параметрами
- Используй `late final` вместо nullable, когда значение точно будет инициализировано
- Избегай `dynamic`, используй явные типы или `Object?`
- Используй `?.` и `??` для безопасной работы с nullable

## Виджеты

- Разбивай большие виджеты на маленькие переиспользуемые компоненты
- Используй `StatelessWidget` когда возможно, `StatefulWidget` только при необходимости состояния
- Используй `const` конструкторы для виджетов без состояния
- Избегай создания виджетов в build методах, выноси их в отдельные методы или классы

## State Management

- Используй `setState` для локального состояния
- Для простого глобального состояния (например, статус подписки) можно использовать простой сервис или Provider
- Избегай сложных state management решений без необходимости

## Производительность

- Используй `ListView.builder` вместо `ListView` для длинных списков
- Используй `const` виджеты для уменьшения перестроек
- Избегай создания объектов в build методах

## Асинхронность

- Используй `async/await` вместо `.then()`
- Обрабатывай ошибки с помощью `try-catch`
- Не забывай проверять `mounted` перед `setState` в асинхронных операциях

## Навигация

- Используй простую навигацию через `Navigator.push` и `Navigator.pushReplacement`
- Передавай данные через конструкторы
- Используй `Navigator.pushReplacement` для замены экрана (например, после онбординга)

## Работа с данными

- Используй `shared_preferences` для сохранения простых данных (статус подписки, завершен ли онбординг)
- Создай сервис для работы с SharedPreferences, не обращайся напрямую
- Используй простые модели данных без сложной сериализации

## Обработка ошибок

- Обрабатывай ошибки с помощью `try-catch`
- Показывай понятные сообщения об ошибках пользователю
- Используй `debugPrint()` для логирования ошибок

## Мобильная специфика

- Учитывай разные размеры экранов, используй `MediaQuery` или `LayoutBuilder`
- Используй `SafeArea` для избежания системных областей
- Используй `SingleChildScrollView` если контент может не поместиться на экран

## Зависимости

- Минимизируй количество зависимостей
- Используй только необходимые пакеты (например, `shared_preferences` для сохранения данных)
- Проверяй совместимость зависимостей

## Форматирование и линтинг

- Используй `dart format` для форматирования кода (аналог Prettier в React)
- Используй `flutter analyze` для проверки кода (аналог ESLint в React)
- Форматирование и сортировка импортов происходят автоматически при сохранении (настроено в `.vscode/settings.json`)
- Импорты автоматически сортируются: dart, flutter, пакеты, относительные
- Следуй правилам из `analysis_options.yaml`
- Используй 2 пробела для отступов
- Используй trailing commas для лучших diffs
- Максимальная длина строки: 80 символов

## Именование

- Используй `lowerCamelCase` для переменных, функций, параметров
- Используй `UpperCamelCase` для классов, типов, enum значений
- Используй `lowercase_with_underscores` для файлов
- Используй `SCREAMING_CAPS` для констант
- Используй префикс `_` для приватных членов

## Публичный API и импорты

### Организация публичного API через index.dart

- **Обязательно создавай `index.dart` файл в каждой папке внутри `lib/`** (constants, models, screens, services, widgets и их подпапки)
- `index.dart` должен экспортировать все публичные классы, функции и константы из модуля
- Используй `export 'filename.dart';` для каждого файла в модуле
- **НЕ создавай `index.dart` в корне `lib/`** - это не является стандартной практикой в Flutter

### Правила импортов

- **Всегда используй импорты через `index.dart`** для доступа к публичному API модуля
- Формат: `import 'package:app/module_name/index.dart';`
- Примеры:
  - `import 'package:app/constants/index.dart';` вместо `import 'package:app/constants/colors_const.dart';`
  - `import 'package:app/models/index.dart';` вместо `import 'package:app/models/subscription.dart';`
  - `import 'package:app/screens/index.dart';` вместо `import 'package:app/screens/home_screen.dart';`
  - `import 'package:app/services/index.dart';` вместо `import 'package:app/services/subscription_service.dart';`
  - `import 'package:app/widgets/ui/index.dart';` вместо `import 'package:app/widgets/ui/button.dart';`

### Исключения из правил импортов

- Если есть конфликт имен (например, два класса с одинаковым именем в разных модулях), используй прямые импорты для избежания конфликта
- Пример: если `SubscriptionCard` существует и в `widgets/home/`, и в `widgets/paywall/`, используй прямые импорты для paywall версии

### Структура index.dart файлов

- В `lib/constants/index.dart`: экспортируй все файлы констант
- В `lib/models/index.dart`: экспортируй все модели
- В `lib/screens/index.dart`: экспортируй все экраны
- В `lib/services/index.dart`: экспортируй все сервисы
- В `lib/widgets/home/index.dart`: экспортируй все виджеты из home
- В `lib/widgets/paywall/index.dart`: экспортируй все виджеты из paywall
- В `lib/widgets/ui/index.dart`: экспортируй все UI виджеты
- В `lib/widgets/index.dart`: экспортируй подпапки виджетов (home, paywall, ui), но учитывай конфликты имен

### Автоматизация

- При создании нового файла в модуле, автоматически добавляй его экспорт в соответствующий `index.dart`
- При изменении импортов, всегда обновляй их на использование `index.dart` вместо прямых импортов файлов

## Что НЕ делать

- Не используй `print()`, используй `debugPrint()`
- Не создавай виджеты в циклах без keys
- Не используй `setState` в build методах
- Не создавай большие виджеты в одном файле
- Не игнорируй предупреждения линтера без веской причины
- Не используй `!` для force unwrap без проверки
- Не хардкодь значения, используй константы

## Когда создавать новые файлы

- Виджет больше 100 строк - вынеси в отдельный файл
- Логика, которая может быть переиспользована - отдельный класс/функция
- Модели данных - отдельные файлы
- Сервисы - отдельные файлы
- Константы - отдельный файл

## Приоритеты

1. Читаемость и поддерживаемость кода
2. Простота реализации
3. Соответствие Flutter best practices
4. Минимизация зависимостей
